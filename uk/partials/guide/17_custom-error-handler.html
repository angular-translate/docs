<h1><code ng:non-bindable=""></code>
<div><span class="hint"></span>
</div>
</h1>
<div><div class="--page"><h2 id="користувацький-обробник-помилок">Користувацький обробник помилок</h2>
<p>Звісно, ви хочете мати можливість використовувати користувацький обробник. Окрім 
<code>useMissingTranslationHandlerLog()</code> є інший метод під назвою <code>useMissingTranslationHandler()</code>,
який отримує ім&#39;я фабрики, що повертає користувацький обробник. Отже, як це виглядає?</p>
<pre class="prettyprint linenums">
var app = angular.module('myApp', ['pascalprecht.translate'], function ($translateProvider) {
  // tell angular-translate to use your custom handler
  $translateProvider.useMissingTranslationHandler('myCustomHandlerFactory');
});

// define custom handler
app.factory('myCustomHandlerFactory', function (dep1, dep2) {
  // has to return a function which gets a tranlation id
  return function (translationID) {
    // do something with dep1 and dep2
  };
});

</pre>
<h2 id="використання-заміщуючого-тексту-у-випадку-помилки">Використання заміщуючого тексту у випадку помилки</h2>
<p>Іноді, може знадобитися вказати заміщуючий текст (не ключ) для фронтенду, щоб перекладачі або,
навіть, кінцеві користувачі (погана ідея) могли бачити над чим ще треба працювати.
Тепер це можливо завдяки трохи зміненому користувацькому обробнику помилок.
Просто поверніть значення з обробника помилок в angular-translate.</p>
<pre class="prettyprint linenums">
app.factory('customTranslationHandler', function () {
  return function (translationID, uses) {
    // return the following text as a translation 'result' - this will be
    // displayed instead of the language key.
    return 'NO DEFAULT KEY';
  };
});
</pre>
<p>Звісно, ви можете додати translationID до значення, що повертається. тоді, відповідальна за
переклади людина побачить проблемний ключ!</p>
<p><br></p>
<p><hr></p>
<center>Made with unicorn &hearts; love by <a href="http://github.com/PascalPrecht">PascalPrecht</a></center></div></div>
